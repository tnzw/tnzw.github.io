<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8>
    <meta name=viewport content="width=device-width,user-scalable=yes,initial-scale=1">
    <title>CodeMirror 5</title>
    <script>
const BANNER=`codemirror5.html Version 0.1.0b
Copyright (c) 2021 Tristan Cavelier <t.cavelier@free.fr>
This program is free software. It comes without any warranty, to
the extent permitted by applicable law. You can redistribute it
and/or modify it under the terms of the Do What The Fuck You Want
To Public License, Version 2, as published by Sam Hocevar. See
http://www.wtfpl.net/ for more details.`,
  TITLE=document.title||(/[^\s]+/).exec(BANNER)[1],
  VERSION=(/Version (.*)/m).exec(BANNER)[1],
  LICENSE=BANNER.replace(/^.*\n/,""),
  fork_me_on="https://github.com/tnzw/tnzw.github.io/blob/master/app/codemirror5.html";

const hasNwJs=typeof nw!=='undefined'&&typeof require!=='undefined';
(function(){"use strict";
window.addEventListener("load", function () {
  const mix=Object.assign;
  const frz=Object.freeze;
  //function mix(o,...oo){for(let _ of oo)for(let k of Object.keys(_))o[k]=_[k];return o}
  function dce(tag,...args){var e=document.createElement(tag);for(let arg of args){if(Array.isArray(arg))for(let a of arg)e.appendChild(typeof a==="string"?document.createTextNode(a):a);else if(typeof arg==="string")e.innerHTML=arg;else if(arg&&typeof arg==="object"){for(let k of Object.keys(arg))if(k.slice(0,2)==="on"&&typeof arg[k]!=="string")e.addEventListener(k.slice(2),arg[k],typeof arg[k]==="object"?arg[k]:0);else e.setAttribute(k,arg[k]);}else if(typeof arg==="function")arg.call(e,e)}return e}
  //XXXfunction dce(tag,...args){var e=document.createElement(tag),o,k2;for(let arg of args){if(Array.isArray(arg))for(let a of arg)e.appendChild(typeof a==="string"?document.createTextNode(a):a);else if(typeof arg==="string")e.innerHTML=arg;else if(typeof arg==="object"&&arg){for(let k of Object.keys(arg))if(k==="on")for(k2 of Object.keys(arg[k])){o=arg[k][k2];e.addEventListener(k2,o,typeof o==="object"?o:0)}else if(k==="attrs")for(k2 of Object.keys(arg[k]))e.setAttribute(k2,arg[k][k2]);else e[k]=arg[k];}else if(typeof arg==="function")arg.call(e,e)}return e}
  const defaultLineSeparator=hasNwJs?(require("process").platform==="win32"?"\r\n":"\n"):"\n";

  const app=window.app={
    state:{modified:false,view:"text",mode:"text",lineSeparator:"\n"},
    hasNwJs,defaultLineSeparator,
    //CodeMirror6 element:dce("div",e=>e.addEventListener("input",_=>{if(!app.state.modified)app.dispatch({modified:1})},{passive:true})),
    element:dce("textarea",{style:"display:none"}),
    editor:null,
    //OLD update(m){let frz=Object.freeze,o={},n={},u={};if('password' in m){this.crypto.setPassword(m.password);if((/^https?:\/\//).test(location.href)){m=Object.assign({},m,{password:!!m.password})}}for(let k of Object.keys(m||0))if(m[k]!==this.state[k]){o[k]=this.state[k];n[k]=m[k];u[k]=1}if(Object.keys(n).length){let ev=frz({type:'appupdate',target:this,updates:frz(n),updated:frz(o),isupdated:frz(u)});this.onupdate(ev);for(let el of this.element.querySelectorAll('[onappupdate]'))new Function('event',el.getAttribute('onappupdate')).call(el,ev)}},
    //OLD dispatch(m){var ev=frz({type:"appupdate",target:this,updates:frz(mix({},m))});this.update(ev.updates);for(let el of this.element.querySelectorAll('[onappupdate]'))new Function('event',el.getAttribute('onappupdate')).call(el,ev)},
    dispatch(m){this.update(Object.freeze(Object.assign({},m)))},
    update(m){var _,oldviewdata,updatetitle,actualView;
      var s=this.state,n={modified:s.modified};
      var directAssignmentKeys = ["file","filename","filepath"];
      for(let k of directAssignmentKeys){if(k in m)n[k]=m[k]}
      //if('password' in m)this.crypto.setPassword(m.password);
      if("lineSeparator" in m){n.lineSeparator=m.lineSeparator??this.defaultLineSeparator}
      if("actualView" in m){_=(""+(m.actualView??""))||"text";if(!(_ in app.contentEncoders))_="text";if(s.view!==_){n.view=_;updatetitle=1;actualView=_}}
      if(      "view" in m){_=(""+(m.      view??""))||"text";if(!(_ in app.contentEncoders))_="text";if(s.view!==_){n.view=_;updatetitle=1;oldviewdata=this.decodeContent(this.getRawContent(),actualView)}}
      if(hasNwJs&&'filepath' in m||'filename' in m)updatetitle=1;
      if(m.modified!==undefined){if(!s.modified&&m.modified)updatetitle=1;n.modified=!!m.modified}
      //CodeMirror6 if(m.mode!==undefined){XXX}
      if("mode" in m){_=""+(m.mode??"text").toLowerCase();n.mode=({htm:"htmlmixed",html:"htmlmixed",c:"clike",js:"javascript",md:"markdown",py:"python",sh:"shell"})[_]||_;app.editor.setOption("mode",n.mode)}
      //CodeMirror6 if(m.theme!==undefined){XXX}
      if("theme" in m){n.theme=""+(m.theme??"default");app.editor.setOption("theme",n.theme)}
      (async function(){try{var data,ol=0,o={};
        if('data' in m && !('changes' in m)){++ol;data=m.data}
        else if('file' in m && !('data' in m) && !('changes' in m)){++ol;data=m.file}
        if(oldviewdata){++ol;data=oldviewdata;oldviewdata=null}
        if(ol){
          data=this.isPrimitive(data)?""+data:data;
          data=await this.unblob(data,"bytes");
          n.lineSeparator=this.detectLineSeparator(data)||this.defaultLineSeparator;
          data=this.encodeContent(data,n.view);
          //CodeMirror6 o={changes:{from:0,to:this.editor.state.doc.length,insert:data}};
          o={changes:{from:0,insert:data}};
        }
        //CodeMirror6 if(ol)this.editor.dispatch(o);
        if(ol)this.editor.setValue(o.changes.insert);
        mix(s, n);  // set state
        if(updatetitle){
          updatetitle=TITLE;
          if(hasNwJs&&s.filepath!==undefined){_=require('path').parse(s.filepath);updatetitle=`${_.base} (${_.dir}) | ${updatetitle}`}
          else if(s.filename!==undefined)updatetitle=`${s.filename} | ${updatetitle}`;
          else updatetitle="new | "+updatetitle;
          if((s.view??"text")!=="text")updatetitle=`${s.view}: ${updatetitle}`;
          if(s.modified)updatetitle="*"+updatetitle;
          document.title=updatetitle;
        }
      }catch(err){alert(err.stack)}}).call(this);
    },
    detectLineSeparator(data){var _,i=0,s=0;if(typeof data==="string")return(_=/(\r\n|\r|\n)/.exec(data))&&_&&_[1]||"";for(;i<data.length;++i){_=data[i];switch(s){case 0:if(_===10)return "\n";if(_===13)s=1;break;case 1:return _===10?"\r\n":"\r"}}return s===1?"\r":"\n"},
    encodeContent(data,view){return this.contentEncoders[view??this.state.view].encode(data,this)},
    decodeContent(text,view){return this.contentEncoders[view??this.state.view].decode(text,this)},
    //CodeMirror6 getRawContent(){return this.editor.state.doc.toString()},
    //CodeMirror6 setRawContent(data){return this.editor.dispatch({changes:{from:0,to:this.editor.state.doc.length,insert:""+data}})},
    getRawContent(){return this.editor.getValue()},
    setRawContent(data){return this.editor.setValue(""+data)},
    getContent(){return this.decodeContent(this.getRawContent())},
    setContent(data){return this.update({data})},
    extname(name){return name.slice(1).replace(/[^\.]*\./g,"")},
    strSize(size){var sizes=['B','KB','MB','GB','TB','PB'],i=0,l=sizes.length-1;while(i<l&&size>9999){i++;size=(size/1000)|0;}return size+sizes[i]},
    openFile(opt,fn){var f=this.fileElement;f[(opt.multiple?'set':'remove')+'Attribute']('multiple','multiple');if(hasNwJs)f[(this.state.filepath?'set':'remove')+'Attribute']('nwworkingdir',this.state.filepath&&require('path').dirname(this.state.filepath));f[(opt.nwsaveas?'set':'remove')+'Attribute']('nwsaveas',this.state.filename);f.onchange=fn;f.click()},
    loadFile(file,mode){if(file===null)return;
      if(file===undefined)return this.openFile({},e=>this.loadFile(e.target.files[0]||null,mode||this.extname(e.target.files[0].name)));
      if(this.state.modified)if(!confirm('Load document? Changes that you made may not be saved.'))return;
      if(file.size>10*1024*1024)if(!confirm(`Do you really want to upload this large file ? (${this.strSize(file.size)})`))return;
      this.update({file:file,filepath:file.path,filename:file.name,modified:0,mode});
    },
    downloadData(data,as,opt){let a=this.downloadElement;a.href=window.URL.createObjectURL(new Blob([data],opt));a.download=as;setTimeout(_=>a.href='#',100);a.click()},
    saveFile(as,opt){if(as!==undefined)if(!as)return;var data;
      if(as===undefined){if(hasNwJs)return this.openFile({nwsaveas:1},e=>this.saveFile(e.target.files[0].path,opt));return this.saveFile(prompt('Save as…',this.state.filename),opt)}
      data=this.getContent();
      // XXX password ?
      if(hasNwJs){
        require('fs').writeFileSync(as,data);//alert('Saved.');
        return this.update({modified:0,filepath:as,filename:require('path').basename(as)});
      }
      this.downloadData(data,as,{type:"application/octet-stream"});
      // no way to know if it's actually downloaded
      return this.update({modified:0,filename:as});
    },
    reloadFile(){
      var filepath,file;
      if(hasNwJs){
        filepath=this.state.filepath;
        if(filepath){
          if(!confirm('Reload document? Changes that you made may not be saved.'))return;
          app.dispatch({data:`Loading "${filepath}"…`,filepath:undefined,modified:0});
          require("fs").readFile(filepath, (err,buf)=>{
            if (err) return app.dispatch({data:`Fail to load "${filepath}"!…\n${err}`,filepath:undefined,modified:0});
            app.dispatch({data:new Uint8Array(buf),filepath,modified:0});
          });
        }
        return;
      }
      file=this.state.file;
      if(file){
        if(!confirm('Reload document? Changes that you made may not be saved.'))return;
        app.dispatch({file:file,modified:0});
      }
    },
    isPrimitive(v){return({string:1,boolean:1,undefined:1})[typeof v]?true:false},
    convert(data,as){switch(as){
      case "text":case "string":if(typeof data==="string")return data;return new TextDecoder().decode(data);
      case "bytes":case "uint8array":if(typeof data!=="string")return data;return new TextEncoder().encode(data);
      default:throw new Error('unhandled `as = '+as+'`');
    }},
    readBlob(blob, as) {
      var d={},fr=new FileReader();
      d.p=new Promise((r,j)=>{d.r=r;d.j=j});
      as=as&&as.toLowerCase();
      if(({bytes:1,uint8array:1})[as])fr.onload=e=>d.r(new Uint8Array(e.target.result));
      else fr.onload=e=>d.r(e.target.result);
      fr.onerror=fr.onabort=e=>d.j(e.target.error);
      d.p.cancel=_=>fr.abort();
      switch (as) {
        case 'arraybuffer':case 'bytes':case 'uint8array': fr.readAsArrayBuffer(blob); break;
        case 'text': case 'string': case undefined: fr.readAsText(blob); break;
        case 'dataurl': fr.readAsDataURL(blob); break;
        case 'binarystring': if (fr.readAsBinaryString) { fr.readAsBinaryString(blob); break; }
        default: throw new Error('unhandled `as = ' + as + '`');
      }
      return d.p;
    },
    async unblob(data,as){if(data instanceof Blob)return new Uint8Array(await this.readBlob(data,as));return data},
    //crypto:(function lib() {
    //  var _password='';
    //  /* Encryption inspired by openssl aes-256-cbc. */
    //  async function OPENSSL_EVP_BytesToKey(hash, nhash, salt, password, count, key, ksize, iv, vsize) {
    //    var nkey = ksize, niv = vsize, addmd = 0, i = 1, ki = 0, vi = 0, update = null, digest = null;
    //    for (;;) { update = []; if (addmd++) update.push.apply(update, digest); update.push.apply(update, password); if (salt) update.push.apply(update, salt); digest = await hash(update);
    //      for (i = 1; i < count; i += 1) digest = await hash(digest); i = 0; if (nkey) { for (;;) { if (nkey === 0) if (i === nhash) break; if (key) key[ki++] = digest[i]; nkey--; i++; } }
    //      if (niv && (i !== nhash)) { for (;;) { if (niv === 0) break; if (i === nhash) break; if (iv) iv[vi++] = digest[i]; niv--; i++; } } if (nkey === 0 && niv === 0) break; }
    //    return ksize;
    //  }
    //  async function hash(data) { if (typeof data === 'string') data = new TextEncoder().encode(data); return new Uint8Array(await crypto.subtle.digest('SHA-256', new Uint8Array(data))); }
    //  async function encrypt(data,password) {
    //    if(password===undefined)password=_password;
    //    if(typeof password==='string')password=new TextEncoder().encode(password);
    //    if(typeof data==='string')data=new TextEncoder().encode(data);
    //    var salt = crypto.getRandomValues(new Uint8Array(8)), iv = new Uint8Array(16), key = new Uint8Array(32);
    //    await OPENSSL_EVP_BytesToKey(hash, 32, salt, password, 1, key, 32, iv, 16);
    //    key = await crypto.subtle.importKey('raw', key, 'AES-CBC', true, ['encrypt', 'decrypt']);
    //    data = new Uint8Array(await crypto.subtle.encrypt({name: 'AES-CBC', iv: iv}, key, data));
    //    return Uint8Array.from((function* (aa) { for (let a of aa) for (let v of a) yield v; })([salt, data]));
    //  }
    //  async function decrypt(data,password) {
    //    if(password===undefined)password=_password;
    //    if(typeof password==='string')password=new TextEncoder().encode(password);
    //    data = new Uint8Array(data);
    //    var salt = data.subarray(0, 8), iv = new Uint8Array(16), key = new Uint8Array(32);
    //    await OPENSSL_EVP_BytesToKey(hash, 32, salt, password, 1, key, 32, iv, 16);
    //    key = await crypto.subtle.importKey('raw', key, 'AES-CBC', true, ['encrypt', 'decrypt']);
    //    return new Uint8Array(await crypto.subtle.decrypt({name: 'AES-CBC', iv: iv}, key, data.subarray(8)));
    //  }
    //  async function magic(data){return btoa(String.fromCharCode(...await hash(data))).slice(0,3)}
    //  function setPassword(password){_password=password}
    //  return Object.freeze({OPENSSL_EVP_BytesToKey,hash,magic,encrypt,decrypt,setPassword,lib});
    //})(),
    parsePromptArguments(string) {
      // nearly shell like arguments
      var args = [], expectedindex = -1 >>> 1;
      string.replace(/(?:"((?:\\.|[^\\"])*)"|'([^']*)'|([^\\"' \t]+)|(\\.)|([\\"']))/g, function (m, dq, sq, r, bs, q, i) {
        var s = "";
        if (args.length === 0) args.push("");
        if (dq !== undefined) s = dq.replace(/\\"/g, '"');
        else if (sq !== undefined) s = sq;
        else if (r !== undefined) s = r;
        else if (bs !== undefined) s = bs.slice(1, 2);
        else if (q !== undefined) s = q;
        if (i <= expectedindex) args[args.length - 1] += s;
        else args.push(s);
        expectedindex = i + m.length;
      });
      return args;
    },
    commands: {
      "":(cm,cmd)=>alert(`unknown command ${cmd}`),
      help(){alert(Object.keys(appCommands))},
      eval(cm,cmd){try{eval(cmd.slice(0,5))}catch(err){alert(err&&(err.stack?err.stack:err.message?err.message:err))}},
      evalfile(cm){try{if(app.state.mode!=="javascript")throw {message:"Error: not in javascript mode"};eval(app.getContent())}catch(err){alert(err&&(err.stack?err.stack:err.message?err.message:err))}},
      mode(cm,cmd,args){if(args[1]===undefined)return alert(app.state.mode);app.dispatch({mode:args[1]})},
      theme(cm,cmd,args){if(args[1]===undefined)return alert(app.state.theme);app.dispatch({theme:args[1]})},
      open(){app.loadFile()},
      save(cm,cmd,args){app.saveFile(args[1])},
      linesep(cm,cmd,args){switch(args[1]){case undefined:var ls=app.state.lineSeparator;return alert(ls==="\r\n"?"CRLF (Windows style)":ls==="cr"?"CR (Mac style)":"LF (unix style)");case "crlf":case "lf":return app.dispatch({lineSeparator:args[1]==="crlf"?"\r\n":"\n"});default:alert(`unhandled linesep ${args[1]}`)}},
      view(cm,cmd,args){if(args[1]===undefined){return alert(app.state.view)}if(args[1] in app.contentEncoders)return app.dispatch({view:args[1]});alert(`unknown view ${args[1]}`)},
      actualview(cm,cmd,args){if(args[1]===undefined){return alert(app.state.view)}if(args[1] in app.contentEncoders)return app.dispatch({actualView:args[1]});alert(`unknown view ${args[1]}`)},
      //CodeMirror6 tabsize(cm){alert(cm.state.facet(CM["@codemirror/state"].EditorState.tabSize))},
    },
    contentEncoders: {
      text:{encode(data,app){var ls=app.state.lineSeparator;return app.contentEncoders[ls==="\r\n"?"crlf":ls==="cr"?"cr":"lf"].encode(data,app)},
            decode(data,app){var ls=app.state.lineSeparator;return app.contentEncoders[ls==="\r\n"?"crlf":ls==="cr"?"cr":"lf"].decode(data,app)}},
      crlf:{encode(data){if(typeof data==="string")return data.replace(/\r\n/g,"\n");return new TextDecoder().decode(data).replace(/\r\n/g,"\n")},decode:_=>_.replace(/\n/g,"\r\n")},
      cr:{encode(data){if(typeof data==="string")return data.replace(/\r/g,"\n");return new TextDecoder().decode(data).replace(/\r/g,"\n")},decode:_=>_.replace(/\n/g,"\r")},
      lf:{encode(data){if(typeof data==="string")return data;return new TextDecoder().decode(data)},decode:_=>_},
      hex:{
        dumpBytesToHexadecimal(bytes) {
          // 63 6f 75 63 6f 75 63 6f  75 63 6f 75 63 6f 75 63  |coucoucoucoucouc| 00000000
          // 6f 75                                             |ou|               00000010
          var res = "", memi = 0, bi = 0, ai = 0, l = bytes.length;
          for (memi = 0; memi < l; memi += 0x10) {
            res += ("0" + bytes[bi++].toString(16)).slice(-2) + " ";
            while (bi < l && bi % 0x08) res += ("0" + bytes[bi++].toString(16)).slice(-2) + " ";
            res += " ";
            while (bi < l && bi % 0x10) res += ("0" + bytes[bi++].toString(16)).slice(-2) + " ";
            if (bi % 0x10) res += "   ".repeat(0x10 - (bi % 0x10)) + " |";
            else res += " |";
            do {
              if (bytes[ai] >= 32 && bytes[ai] <= 126) res += String.fromCharCode(bytes[ai]);
              else res += ".";
              ai += 1;
            } while (ai < l && ai % 0x10);
            res += "|";
            if (ai % 0x10) { do { res += " " } while (ai++ % 0x10); }
            else res += " ";
            res += ("0000000" + memi.toString(16)).slice(-8) + "\n";
          }
          //res += ("0000000" + bytes.length.toString(16)).slice(-8);
          return res;
        },
        decodeHexadecimalWithCommentsToBytes(text) {
          text = text.replace(/\|.*/gm, "").replace(/\s/g, "")  // ignore comments and whitespaces
          if (/[^a-fA-F0-9]/.test(text)) throw new Error("invalid character");
          if (text.length % 2) throw new Error("text.length % 2 !== 0");
          var i = 0, j = 0,
              bytes = new Array(text.length / 2);
          for (; i < text.length; i += 2)
            bytes[j++] = parseInt(text.slice(i, i + 2), 16);
          return bytes;
        },
        encode(data,app){return this.dumpBytesToHexadecimal(app.convert(data,"bytes"))},
        decode(text){return new Uint8Array(this.decodeHexadecimalWithCommentsToBytes(text))},
      },
      repr: {
        createReprFromBytes(bytes) {
          var s = "", i = 0, byte = 0;
          for (; i < bytes.length; i += 1) {
            byte = bytes[i] & 0xFF;
            if (byte === 0x0A) { s += "\n"; }
            else if (byte === 0x09) { s += "\\t"; }
            else if (byte === 0x0D) { s += "\\r"; }
            else if (byte === 0x08) { s += "\\b"; }
            else if (byte === 0x0C) { s += "\\f"; }
            else if (byte === 0x0B) { s += "\\v"; }
            //else if (byte === 0x22) { s += "\\\""; }
            else if (byte === 0x5C) { s += "\\\\"; }
            else if (byte < 0x10) { s += "\\x0" + byte.toString(16); }
            else if (byte < 0x20 || byte >= 0x7F) { s += "\\x" + byte.toString(16); }
            else { s += String.fromCharCode(byte); }
          }
          return s;
        },
        createReprFromString(string){return this.createReprFromBytes(this.createBytesFromString(string))},
        createBinaryStringFromRepr(repr){
          return repr.replace(/[\x80-\uffff]+/g, function (m) {
            return String.fromCharCode.apply(String, this.createBytesFromString(m));
          }).replace(/\\([ntrbfv"\\])/g, function (m, g) {
            switch (g) {
              case "n": return "\n";
              case "t": return "\t";
              case "r": return "\r";
              case "b": return "\b";
              case "f": return "\f";
              case "v": return "\v";
              case "\"": return "\"";
              case "\\": return "\\";
            }
            return m;
          }).replace(/\\x([0-9A-Fa-f]{2})/g, function (m, x) {
            return String.fromCharCode(parseInt(x, 16));
          });
        },
        createBytesFromBinaryString(binaryString) {
          var bytes = new Array(binaryString.length), i = 0;
          for (; i < binaryString.length; i += 1) bytes[i] = binaryString.charCodeAt(i) & 0xFF;
          return bytes;
        },
        createBytesFromRepr(repr) {return this.createBytesFromBinaryString(this.createBinaryStringFromRepr(repr))},
        createStringFromRepr(repr) {return this.createStringFromBytes(this.createBytesFromRepr(repr))},
        encode(data,app){return this.createReprFromBytes(app.convert(data,"bytes"))},
        decode(text){return new Uint8Array(this.createBytesFromRepr(text))},
      },
    },
    tags: {
      language: Symbol("language"),
    },
  };

  document.body.appendChild(app.element);
  document.body.appendChild(dce("div",{style:"opacity:0;position:fixed;width:1px;height:1px;top:0;left:0;z-index:-1"},[
    app.downloadElement=dce("a",{download:"untitled.txt",href:"#",tabindex:"-1"},[" "]),
    app.fileElement=dce("input",{type:"file",tabindex:"-1"})
  ]));

  window.addEventListener("keydown",e=>{  // CodeMirror6 cannot handle openFile etc… no preventDefault done ?
    if(e.ctrlKey&&e.key.toLowerCase()==="o"){e.preventDefault();app.loadFile()}  // (browser open file)
    if(e.ctrlKey&&e.shiftKey&&e.key.toLowerCase()==="s"){e.preventDefault();app.saveFile()}  // (browser save page)
    else if(e.ctrlKey&&e.key.toLowerCase()==="s"){e.preventDefault();app.saveFile(hasNwJs?app.state.filepath:app.state.filename)}  // (browser save page)
    if(e.ctrlKey&&e.key.toLowerCase()==="r"){e.preventDefault();app.reloadFile()}  // (browser refresh page)
  });
  hasNwJs&&window.addEventListener("keydown",e=>{
    if(e.ctrlKey&&e.key.toLowerCase()==="n"){e.preventDefault();nw.Window.open(location.href.replace(/[\?#].*$/,""),{new_instance:true,focus:true})}
    //if(e.ctrlKey&&e.key.toLowerCase()==="w"){e.preventDefault();if(typeof window.onbeforeunload==="function")try{if(!window.onbeforeunload()||!confirm("Leave app? Changes that you made may not be saved."))return}catch(_){}nw.Window.get().close()}
    if(e.ctrlKey&&e.key.toLowerCase()==="w"){e.preventDefault();nw.Window.get().close()}
  });
  window.onbeforeunload = function () { return app.state.modified?"No!":undefined; };

  function promptRun(cm) {
    var cmd = prompt("Command… (type `help` for help)");
    if (cmd === null) return;
    var args = app.parsePromptArguments(cmd);
    (app.commands[args[0]] || app.commands[""])(cm,cmd,args);
    return true;
  }

  function autocompleteWordOnInputListener(e) {  // only used for CodeMirror6
    e.target.removeEventListener("input", autocompleteWordOnInputListener);
    delete e.target.tcAutocompleteWordVars;
  }
  function autocompleteWordOnChangeListener(cm) {  // only used for CodeMirror5
    cm.off("change", autocompleteWordOnChangeListener);
    delete cm.tcAutocompleteWordVars;
  }
  function autocompleteWord(cm, reverse) {
    //CodeMirror6 var vars = cm.contentDOM.tcAutocompleteWordVars, cursor = cm.state.selection.ranges[0].to,
    var vars = cm.tcAutocompleteWordVars, cursor = cm.getCursor(),
        wordsDict = {}, words, index, firstText, lastText, wordPart, re, text;
    function add(word) {
      delete wordsDict[word];
      wordsDict[word] = null;
      return word;
    }
    //CodeMirror6 if (vars && vars.location && vars.location === cursor && vars.words && (text=cm.state.doc.toString()).slice(0, cursor).endsWith(vars.words[vars.index || 0])) {
    if (vars && vars.location && vars.location.line === cursor.line && vars.location.ch === cursor.ch && vars.words && cm.getLine(cursor.line).slice(0, cursor.ch).endsWith(vars.words[vars.index || 0])) {
      // go to next index
      index = vars.index;
      if (reverse) {
        if (index < vars.words.length - 1) { index += 1 } else { index = 0 }
      } else {
        if (index > 0) { index -= 1 } else { index = vars.words.length - 1 }
      }
      //*CodeMirror5*\
      cm.off("change", autocompleteWordOnChangeListener);
      cm.replaceRange(vars.words[index], {line: cursor.line, ch: cursor.ch - vars.words[vars.index].length}, cursor);
      vars.location = {line: cursor.line, ch: cursor.ch - vars.words[vars.index].length + vars.words[index].length};
      cm.on("change", autocompleteWordOnChangeListener);
      //*CodeMirror5*/
      /*CodeMirror6*\
      cm.contentDOM.removeEventListener("input", autocompleteWordOnInputListener);
      for(let _ of vars.words[vars.index])CM["@codemirror/commands"].selectCharBackward(cm);cm.dispatch(cm.state.replaceSelection(vars.words[index]));
      vars.location = cursor - vars.words[vars.index].length + vars.words[index].length;
      cm.contentDOM.addEventListener("input", autocompleteWordOnInputListener, {passive:true});
      //*CodeMirror6*/
      vars.index = index;
    } else {
      // store words and go to first index
      //CodeMirror6 firstText = (text=text||cm.state.doc.toString()).slice(0,cursor).replace(/\w+$/, function (match) { wordPart = match; return ""; });
      firstText = cm.getRange({"line": 0, "ch": 0}, cursor).replace(/\w+$/, function (match) { wordPart = match; return ""; });
      if (!wordPart) { return; }
      text = cm.getValue();  //CodeMirror5 only
      lastText = text.slice(firstText.length).replace(/^\w+/, "");
      re = new RegExp("\\b" + wordPart + "\\w+", "g");
      lastText.replace(re, add);
      firstText.replace(re, add);
      words = Object.keys(wordsDict);
      if (!words.length) return;
      if (reverse) index = 0;
      else index = words.length - 1;
      wordPart = words[index].slice(wordPart.length);
      //*CodeMirror5*\
      cm.off("change", autocompleteWordOnChangeListener);
      cm.replaceRange(wordPart, cursor, cursor);
      cursor.ch += wordPart.length;
      cm.tcAutocompleteWordVars = {location:cursor,words:words,index:index};
      cm.on("change", autocompleteWordOnChangeListener);
      //*CodeMirror5*/
      /*CodeMirror6*\
      cm.contentDOM.removeEventListener("input", autocompleteWordOnInputListener);
      cm.dispatch(cm.state.replaceSelection(wordPart));
      cursor += wordPart.length;
      cm.contentDOM.tcAutocompleteWordVars = {location:cursor,words:words,index:index};
      cm.contentDOM.addEventListener("input", autocompleteWordOnInputListener, {passive:true});
      //*CodeMirror6*/
    }
  }
  function autocompleteWordReverse(cm) { return autocompleteWord(cm, true) }

  //* BEGIN CodeMirror5 *\

  // Vocabulary:
  // - Right: from the cursor, match the next on the document, until the end of document
  // - After: from the cursor, match the next on the line, until the end of line. If cursor is on eol, then match also on the next line
  // - Left: from the cursor, match the previous on the document, until the beginning of document
  // - Before: from the cursor, match the previous on the line, until the beginning of line. If cursor is on bol, then match also on the previous line

  function operateUntilWordAfter(cm, op) {
    var start = cm.getCursor(), end = cm.findPosH(start, 1, "word");
    cm.replaceRange(op(cm.getRange(start, end)), start, end);
    cm.setCursor(end);
  }

  function operateOnCharAfter(cm, op) {
    var start = cm.getCursor(), end = cm.findPosH(start, 1, "char");
    cm.replaceRange(op(cm.getRange(start, end)), start, end);
    cm.setCursor(end);
  }

  function capitalize(string) {
    return string.replace(/\w+/g, function (word) {
      return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();
    });
  }

  function reverseCase(string) {
    var i, l, str = "", chr;
    for (i = 0, l = string.length; i < l; i += 1) {
      chr = string[i].toUpperCase();
      if (chr !== string[i]) {
        str += chr;
        continue;
      }
      chr = string[i].toLowerCase();
      str += chr;
    }
    return str;
  }

  function setOrUnsetMark(cm) {
    cm.setCursor(cm.getCursor());
    cm.setExtending(!cm.getExtending());
    function setExtendingToFalse() {
      cm.off("change", setExtendingToFalse);
      cm.setExtending(false);
    }
    cm.on("change", setExtendingToFalse);
  }

  function convertSelectionToSquareSelection(cm) {
    var anchor = cm.getCursor("from"), head = cm.getCursor("to"), leftCh = (anchor.ch < head.ch ? anchor.ch : head.ch), i;
    cm.setSelection(anchor, {line: anchor.line, ch: head.ch});
    if (anchor.line < head.line) {
      for (i = anchor.line + 1; i <= head.line; i += 1) {
        if (cm.getLine(i).length >= leftCh) {
          cm.addSelection({line: i, ch: anchor.ch}, {line: i, ch: head.ch});
        }
      }
    } else {
      for (i = anchor.line - 1; i >= head.line; i -= 1) {
        if (cm.getLine(i).length >= leftCh) {
          cm.addSelection({line: i, ch: anchor.ch}, {line: i, ch: head.ch});
        }
      }
    }
    //cm.setExtending(false);
  }
  CodeMirror.commands.tcConvertSelectionToSquareSelection = convertSelectionToSquareSelection;

  //function clearMark(cm) {
  //  cm.setExtending(false);
  //  cm.setCursor(cm.getCursor());
  //}

  // XXX TODO moveBlockOrLineUp
  function moveLineUp(cm) {
    var cursor = cm.getCursor(), lineUp, lineDown;
    lineUp = cm.getRange({"line": cursor.line - 1, "ch": 0}, {"line": cursor.line, "ch": 0});
    if (lineUp === "") { return; }
    lineDown = cm.getRange({"line": cursor.line, "ch": 0}, {"line": cursor.line + 1, "ch": 0});
    if (lineDown[lineDown.length - 1] !== "\n") {
      lineUp = lineUp.slice(0, -1);
      lineDown += "\n";
    }
    cm.replaceRange(lineDown + lineUp, {"line": cursor.line - 1, "ch": 0}, {"line": cursor.line + 1, "ch": 0});
    cm.setCursor({"line": cursor.line - 1, "ch": cursor.ch});
  }

  // XXX TODO moveBlockOrLineDown
  function moveLineDown(cm) {
    var cursor = cm.getCursor(), lineUp, lineDown;
    lineUp = cm.getRange({"line": cursor.line, "ch": 0}, {"line": cursor.line + 1, "ch": 0});
    if (lineUp[lineUp.length - 1] !== "\n") { return; }
    lineDown = cm.getRange({"line": cursor.line + 1, "ch": 0}, {"line": cursor.line + 2, "ch": 0});
    if (lineDown[lineDown.length - 1] !== "\n") {
      lineUp = lineUp.slice(0, -1);
      lineDown += "\n";
    }
    cm.replaceRange(lineDown + lineUp, {"line": cursor.line, "ch": 0}, {"line": cursor.line + 2, "ch": 0});
    cm.setCursor({"line": cursor.line + 1, "ch": cursor.ch});
  }

  function transposeWords(cm) {
    // TODO does not work with "  function transposeWords(cm) {" with cursor between "transposeWords" and "cm", and also between "cm" and the end of the line
    var wordOneStart, wordOneEnd, wordTwoStart, wordTwoEnd, wordOne, wordTwo, offset;
    wordOneStart = cm.findPosH(cm.getCursor(), -1, "word");
    wordOneEnd = cm.findPosH(wordOneStart, 1, "word");
    wordTwoEnd = cm.findPosH(wordOneEnd, 1, "word");
    wordTwoStart = cm.findPosH(wordTwoEnd, -1, "word");
    wordOne = cm.getRange(wordOneStart, wordOneEnd);
    wordTwo = cm.getRange(wordTwoStart, wordTwoEnd);
    console.log(wordOne);
    console.log(wordTwo);
    offset = wordTwo.length - wordOne.length;
    cm.replaceRange(wordTwo, wordOneStart, wordOneEnd);
    cm.replaceRange(wordOne, cm.findPosH(wordTwoStart, offset, "char"), cm.findPosH(wordTwoEnd, offset, "char"));
    cm.setCursor(wordTwoEnd);
  }

  //function removeSpacesAtCursor(cm) {
  //  if (cm.getOption("readOnly")) { return; }
  //  var cursor, col;
  //  while (true) {
  //    cursor = cm.getCursor();
  //    col = cm.findPosH(cursor, -1, "column");
  //    if (/\s/.test(cm.getRange(col, cursor))) {
  //      cm.replaceRange("", col, cursor);
  //    } else {
  //      break;
  //    }
  //  }
  //  while (true) {
  //    cursor = cm.getCursor();
  //    col = cm.findPosH(cursor, 1, "column");
  //    if (/\s/.test(cm.getRange(cursor, col))) {
  //      cm.replaceRange("", cursor, col);
  //    } else {
  //      break;
  //    }
  //  }
  //}
  //CodeMirror.commands.tcRemoveSpacesAtCursor = removeSpacesAtCursor;

  CodeMirror.commands.tcAutocompleteWord = autocompleteWord;
  CodeMirror.commands.tcAutocompleteWordReverse = function (cm) { return autocompleteWord(cm, true); };

  function insertNewline(cm) { cm.replaceSelection("\n"); }
  CodeMirror.commands.tcInsertNewline = insertNewline;
  function doNothing() { return; }
  CodeMirror.commands.tcDoNothing = doNothing;

  // keymap samples emacs-Ctrl-X {"auto": "emacs", "nofallthrough": true, "disableInput": true}
  //                emacs-Ctrl-Q {"auto": "emacs", "nofallthrough": true}

  CodeMirror.keyMap.default.F3 = "findNext";
  CodeMirror.keyMap.default["Shift-F3"] = "findPrev";
  CodeMirror.keyMap.default["Ctrl-O"] = "open";
  CodeMirror.keyMap.default["Shift-Ctrl-S"] = "saveas";
  CodeMirror.keyMap.default["Ctrl-Shift-S"] = "saveas";

  CodeMirror.keyMap.default.F2 = promptRun;
  CodeMirror.keyMap.default["Shift-F2"] = app.commands.evalfile;

  // CodeMirror.keyMap.tc = updateObject({}, CodeMirror.keyMap["default"]);
  CodeMirror.keyMap.tc = {"fallthrough": "default"};
  CodeMirror.keyMap.tc.Enter = insertNewline;
  CodeMirror.keyMap.tc.Tab = "insertSoftTab";
  //CodeMirror.keyMap.tc.F3 = "findNext";  // set to default

  CodeMirror.keyMap.tc["Alt-A"] = "goLineEnd";
  CodeMirror.keyMap.tc["Alt-B"] = "goGroupLeft";
  CodeMirror.keyMap.tc["Alt-C"] = function (cm) {
    operateOnCharAfter(cm, reverseCase);
  };
  CodeMirror.keyMap.tc["Alt-D"] = "delWordAfter";  // "duplicateLine";
  CodeMirror.keyMap.tc["Alt-E"] = "goGroupRight";
  CodeMirror.keyMap.tc["Alt-F"] = doNothing;
  CodeMirror.keyMap.tc["Alt-H"] = "goCharLeft";  // "goColumnLeft";
  CodeMirror.keyMap.tc["Alt-I"] = "indentAuto";
  CodeMirror.keyMap.tc["Alt-J"] = "goLineDown";
  CodeMirror.keyMap.tc["Alt-K"] = "goLineUp";
  CodeMirror.keyMap.tc["Alt-L"] = "goCharRight";  // "goColumnRight";
  CodeMirror.keyMap.tc["Alt-M"] = insertNewline;  // "goLineStartSmart";
  CodeMirror.keyMap.tc["Alt-N"] = "findNext";
  CodeMirror.keyMap.tc["Alt-O"] = function (cm) {
    cm.execCommand("goLineEnd");
    cm.replaceSelection("\n");
  };
  CodeMirror.keyMap.tc["Alt-P"] = "tcAutocompleteWord";
  // CodeMirror.keyMap.tc["Alt-Q"] = undefined;
  CodeMirror.keyMap.tc["Alt-R"] = "replace";
  CodeMirror.keyMap.tc["Alt-S"] = "delWordBefore";
  CodeMirror.keyMap.tc["Alt-T"] = "transposeChars";
  CodeMirror.keyMap.tc["Alt-U"] = "undo";
  CodeMirror.keyMap.tc["Alt-V"] = setOrUnsetMark;
  CodeMirror.keyMap.tc["Alt-W"] = "goWordRight";
  CodeMirror.keyMap.tc["Alt-X"] = "delCharAfter";
  CodeMirror.keyMap.tc["Alt-Y"] = "duplicateLine";
  CodeMirror.keyMap.tc["Alt-Z"] = "goLineStart";
  CodeMirror.keyMap.tc["Alt-0"] = "goLineStart";
  CodeMirror.keyMap.tc["Alt-/"] = "find";
  CodeMirror.keyMap.tc["Alt-\\"] = "tcRemoveSpacesAtCursor";
  CodeMirror.keyMap.tc["Alt-#"] = "tcRemoveSpacesAtCursor";
  CodeMirror.keyMap.tc["Alt--"] = "tcAutocompleteWord";
  CodeMirror.keyMap.tc["Alt-,"] = "goDocStart";
  CodeMirror.keyMap.tc["Alt-."] = "goDocEnd";
  CodeMirror.keyMap.tc["Alt-;"] = "goDocEnd";
  CodeMirror.keyMap.tc["Alt-Up"] = "goPageUp";  // (NO OTHER CHOICE on chromebooks)
  CodeMirror.keyMap.tc["Alt-Down"] = "goPageDown";  // (NO OTHER CHOICE on chromebooks)
  CodeMirror.keyMap.tc["Alt-Space"] = "tcAutocompleteWord";  // (unreachable on Windows)
  CodeMirror.keyMap.tc["Alt-Backspace"] = "delCharAfter";  // (NO OTHER CHOICE on chromebooks)
  CodeMirror.keyMap.tc["Alt-Enter"] = function (cm) {
    cm.execCommand("tcRemoveSpacesAtCursor");
    cm.execCommand("newlineAndIndent");
  };

  // CodeMirror.keyMap.tc["Ctrl-A"] = undefined;  // (browser select all)
  CodeMirror.keyMap.tc["Ctrl-B"] = doNothing;
  // CodeMirror.keyMap.tc["Ctrl-C"] = undefined;  // (browser copy to clipboard)
  CodeMirror.keyMap.tc["Ctrl-D"] = "delCharAfter";
  // CodeMirror.keyMap.tc["Ctrl-E"] = undefined;
  // CodeMirror.keyMap.tc["Ctrl-F"] = undefined;
  // CodeMirror.keyMap.tc["Ctrl-G"] = undefined;
  CodeMirror.keyMap.tc["Ctrl-H"] = "delCharBefore";
  CodeMirror.keyMap.tc["Ctrl-I"] = "insertTab";
  CodeMirror.keyMap.tc["Ctrl-J"] = insertNewline;
  // CodeMirror.keyMap.tc["Ctrl-K"] = "goLineUp";
  // CodeMirror.keyMap.tc["Ctrl-L"] = "goCharRight";
  CodeMirror.keyMap.tc["Ctrl-M"] = insertNewline;
  // CodeMirror.keyMap.tc["Ctrl-N"] = undefined;  // (browser new window NO OTHER CHOICE)
  // CodeMirror.keyMap.tc["Ctrl-O"] = undefined;
  CodeMirror.keyMap.tc["Ctrl-P"] = doNothing;
  // CodeMirror.keyMap.tc["Ctrl-Q"] = undefined;
  CodeMirror.keyMap.tc["Ctrl-R"] = "redo";  // (browser reload page)
  CodeMirror.keyMap.tc["Ctrl-S"] = "save";
  // CodeMirror.keyMap.tc["Ctrl-T"] = undefined;  // (browser new tab)
  // CodeMirror.keyMap.tc["Ctrl-U"] = "undo";
  // CodeMirror.keyMap.tc["Ctrl-V"] = undefined;  // (browser paste from clipboard)
  // CodeMirror.keyMap.tc["Ctrl-W"] = undefined;  // (browser close window NO OTHER CHOICE)
  // CodeMirror.keyMap.tc["Ctrl-X"] = "delCharAfter";
  // CodeMirror.keyMap.tc["Ctrl-Y"] = undefined;
  // CodeMirror.keyMap.tc["Ctrl-Z"] = undefined;
  CodeMirror.keyMap.tc["Ctrl-Up"] = moveLineUp;
  CodeMirror.keyMap.tc["Ctrl-Down"] = moveLineDown;
  // CodeMirror.keyMap.tc["Ctrl-Backspace"] = undefined;  // (browser delWordBefore)

  CodeMirror.keyMap.tc["Shift-Tab"] = "insertSoftTab";  // TODO ?
  CodeMirror.keyMap.tc["Shift-F3"] = "findPrev";

  // CodeMirror.keyMap.tc["Shift-Alt-A"] = "goLineEnd";
  // CodeMirror.keyMap.tc["Shift-Alt-B"] = undefined;
  CodeMirror.keyMap.tc["Shift-Alt-C"] = function (cm) {
    operateUntilWordAfter(cm, capitalize);
  };
  CodeMirror.keyMap.tc["Shift-Alt-D"] = "deleteLine";
  // CodeMirror.keyMap.tc["Shift-Alt-E"] = "transposeChars";
  CodeMirror.keyMap.tc["Shift-Alt-F"] = doNothing;  // (firefox [File] shortcut)
  CodeMirror.keyMap.tc["Shift-Alt-G"] = doNothing;
  // CodeMirror.keyMap.tc["Shift-Alt-H"] = "goCharLeft";
  CodeMirror.keyMap.tc["Shift-Alt-I"] = "goLineStartSmart";
  // CodeMirror.keyMap.tc["Shift-Alt-J"] = "goLineDown";
  // CodeMirror.keyMap.tc["Shift-Alt-K"] = "goLineUp";
  // CodeMirror.keyMap.tc["Shift-Alt-L"] = "goCharRight";
  // CodeMirror.keyMap.tc["Shift-Alt-M"] = undefined;
  CodeMirror.keyMap.tc["Shift-Alt-N"] = "findPrev";  // TODO ? (chromeos open message center NO OTHER CHOICE)
  CodeMirror.keyMap.tc["Shift-Alt-O"] = function (cm) {
    cm.execCommand("goLineStart");
    cm.replaceSelection("\n");
    cm.execCommand("goCharLeft");
  };
  CodeMirror.keyMap.tc["Shift-Alt-P"] = "tcAutocompleteWordReverse";
  // CodeMirror.keyMap.tc["Shift-Alt-Q"] = undefined;
  CodeMirror.keyMap.tc["Shift-Alt-R"] = "replaceAll";
  CodeMirror.keyMap.tc["Shift-Alt-S"] = "delCharAfter";
  CodeMirror.keyMap.tc["Shift-Alt-T"] = doNothing;  // TODO transposeWords (firefox [Tools] shortcut)
  CodeMirror.keyMap.tc["Shift-Alt-U"] = "redo";
  CodeMirror.keyMap.tc["Shift-Alt-V"] = "tcConvertSelectionToSquareSelection"; // (firefox [View] shortcut)
  // CodeMirror.keyMap.tc["Shift-Alt-W"] = undefined;
  CodeMirror.keyMap.tc["Shift-Alt-X"] = "delCharBefore";
  // CodeMirror.keyMap.tc["Shift-Alt-Y"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Alt-Z"] = undefined;
  CodeMirror.keyMap.tc["Shift-Alt-3"] = doNothing;  // TODO searchThisWordPrevious
  CodeMirror.keyMap.tc["Shift-Alt-4"] = "goLineEnd";
  CodeMirror.keyMap.tc["Shift-Alt-8"] = doNothing;  // TODO searchThisWordNext
  //CodeMirror.keyMap.tc["Shift-Alt-,"] = "goDocStart";
  //CodeMirror.keyMap.tc["Shift-Alt-."] = "goDocEnd";
  //CodeMirror.keyMap.tc["Shift-Alt-<"] = "goDocStart";  // doesn't work
  //CodeMirror.keyMap.tc["Shift-Alt->"] = "goDocEnd";  // doesn't work
  CodeMirror.keyMap.tc["Shift-Alt-["] = "indentLess";
  CodeMirror.keyMap.tc["Shift-Alt-]"] = "indentMore";
  CodeMirror.keyMap.tc["Shift-Alt--"] = "tcAutocompleteWordReverse";
  CodeMirror.keyMap.tc["Shift-Alt-Space"] = "tcAutocompleteWordReverse";
  CodeMirror.keyMap.tc["Shift-Alt-Backspace"] = "delWordAfter";

  // CodeMirror.keyMap.tc["Shift-Ctrl-A"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-B"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-C"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-D"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-E"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-F"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-G"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-H"] = "goCharLeft";
  // CodeMirror.keyMap.tc["Shift-Ctrl-I"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-J"] = "goLineDown";
  // CodeMirror.keyMap.tc["Shift-Ctrl-K"] = "goLineUp";
  // CodeMirror.keyMap.tc["Shift-Ctrl-L"] = "goCharRight";
  // CodeMirror.keyMap.tc["Shift-Ctrl-M"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-O"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-P"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-Q"] = undefined;
  CodeMirror.keyMap.tc["Shift-Ctrl-R"] = doNothing;  // (browser reload page without cache)
  // CodeMirror.keyMap.tc["Shift-Ctrl-S"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-T"] = undefined;  // (browser open recently closed tab)
  // CodeMirror.keyMap.tc["Shift-Ctrl-U"] = "undo";
  // CodeMirror.keyMap.tc["Shift-Ctrl-V"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-W"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-X"] = "delCharAfter";
  // CodeMirror.keyMap.tc["Shift-Ctrl-Y"] = undefined;
  // CodeMirror.keyMap.tc["Shift-Ctrl-Z"] = undefined;
  CodeMirror.keyMap.tc["Shift-Ctrl--"] = "undo";

  const editor = app.editor = window.editor = CodeMirror.fromTextArea(app.element, {
    autofocus: true,  // default false (does not really work)
    autoRefresh: true,  // default false (autorefresh)
    fullScreen: true,  // default false (fullscreen)
    indentWithTabs: false,  // default false
    keyMap: "tc",  // default "default"
    lineNumbers: true,  // default false
    matchBrackets: true,  // default false (matchbrackets)
    mode: "text",  // default "text"
    readOnly: false,  // default false
    showTrailingSpace: true,  // default false (trailingspace)
    smartIndent: false,  // default true
    tabSize: 2,  // default 4
    theme: "default",  // default "default"
  });
  editor.on("change", _=>{if(!app.state.modified)app.dispatch({modified:1})});

  //* END CodeMirror5 */

  /* BEGIN CodeMirror6 *\

  const tcBindings = [
    // XXX what about mac ?  mac: "Alt-x" Alt ? Cmd ? Ctrl ?
    //{key: "Ctrl-o"  , run: cm=>app.openFile()&&true},  // actualy set on global to override default behavior
    //{key: "Ctrl-s"  , run: cm=>app.saveFile()&&true},  // actualy set on global to override default behavior
    {key: "Ctrl-ArrowDown", run: CM["@codemirror/commands"].moveLineDown},
    {key: "Ctrl-ArrowUp"  , run: CM["@codemirror/commands"].moveLineUp  },
    {key: "Alt-a"   , run: CM["@codemirror/commands"].cursorLineEnd      , shift: CM["@codemirror/commands"].selectLineEnd     },
    {key: "Alt-b"   , run: CM["@codemirror/commands"].cursorGroupLeft    , shift: CM["@codemirror/commands"].selectGroupLeft   },
    {key: "Alt-d"   , run: CM["@codemirror/commands"].deleteGroupForward , shift: CM["@codemirror/commands"].deleteLine        },
    {key: "Alt-e"   , run: CM["@codemirror/commands"].cursorGroupRight   , shift: CM["@codemirror/commands"].selectGroupRight  },
    {key: "Alt-f"   , run: _=>undefined                                                                                        },
    {key: "Alt-h"   , run: CM["@codemirror/commands"].cursorCharBackward , shift: CM["@codemirror/commands"].selectCharBackward},
    {key: "Alt-j"   , run: CM["@codemirror/commands"].cursorLineDown     , shift: CM["@codemirror/commands"].selectLineDown    },
    {key: "Alt-k"   , run: CM["@codemirror/commands"].cursorLineUp       , shift: CM["@codemirror/commands"].selectLineUp      },
    {key: "Alt-l"   , run: CM["@codemirror/commands"].cursorCharForward  , shift: CM["@codemirror/commands"].selectCharForward },
    {key: "Alt-m"   , run: CM["@codemirror/commands"].insertNewline                                                            },
    {key: "Alt-o"   , run: cm=>{let c=CM["@codemirror/commands"];c.cursorLineEnd(cm);return c.insertNewline(cm)},
                    shift: cm=>{let c=CM["@codemirror/commands"];c.cursorLineStart(cm);return c.insertNewline(cm)&&c.cursorCharBackward(cm)}},
    {key: "Alt-p"   , run: autocompleteWord, shift: autocompleteWordReverse},
    {key: "Alt-r"   , run: _=>true                                                                                             },
    {key: "Alt-s"   , run: CM["@codemirror/commands"].deleteGroupBackward                                                      },
    {key: "Alt-x"   , run: CM["@codemirror/commands"].deleteCharForward  , shift: CM["@codemirror/commands"].deleteCharBackward},
    {key: "Alt-y"   , run: CM["@codemirror/commands"].copyLineDown       , shift: CM["@codemirror/commands"].copyLineUp        },
    {key: "Alt-z"   , run: CM["@codemirror/commands"].cursorLineStart    , shift: CM["@codemirror/commands"].selectLineStart   },
    {key: "Alt-0"   , run: CM["@codemirror/commands"].cursorLineStart    , shift: CM["@codemirror/commands"].selectLineStart   },
    //does not work {key: "Shift-Alt-0"   , run: CM["@codemirror/commands"].selectLineStart    , shift: CM["@codemirror/commands"].selectLineStart   },
    {key: "Alt-,"   , run: CM["@codemirror/commands"].cursorDocStart     , shift: CM["@codemirror/commands"].selectDocStart    },
    {key: "Alt-;"   , run: CM["@codemirror/commands"].cursorDocEnd       , shift: CM["@codemirror/commands"].selectDocEnd      },
    {key: "Alt-/"   , run: _=>undefined                                                                                        },
    {key: "Alt-ArrowUp"  , run: CM["@codemirror/commands"].cursorPageUp  , shift: CM["@codemirror/commands"].selectPageUp      },  // (NO OTHER CHOICE on chromebooks)
    {key: "Alt-ArrowDown", run: CM["@codemirror/commands"].cursorPageDown, shift: CM["@codemirror/commands"].selectPageDown    },  // (NO OTHER CHOICE on chromebooks)
    // alt-w run: if no selection then go to matching bracket, else go to opposite selection XXX
    //{key: "Tab"     , run: insertTabAsSpace                              , shift: CM["@codemirror/commands"].    },
    {key: "F2", run: promptRun, shift: function(cm){eval(cm.state.doc.toString())}},
  ];

  const {EditorState, EditorView, basicSetup} = CM["@codemirror/basic-setup"];
  const {keymap} = CM["@codemirror/view"];
  const {defaultTabBinding} = CM["@codemirror/commands"];
  const {tagExtension,Transaction} = CM["@codemirror/state"];
  //const {javascript, javascriptLanguage} = CM["@codemirror/lang-javascript"];
  const {javascript} = CM["@codemirror/lang-javascript"];
  const {css} = CM["@codemirror/lang-css"];
  const {markdown} = CM["@codemirror/lang-markdown"];
  const {html} = CM["@codemirror/lang-html"];
  //const {completeFromList} = CM["@codemirror/autocomplete"];
  //let keywords="break case catch class const continue debugger default delete do else enum export extends false finally for function if implements import interface in instanceof let new package private protected public return static super switch this throw true try typeof var void while with yield".split(" ").map(kw=>({label:kw,type:"keyword"}));
  //let globals=Object.getOwnPropertyNames(window).map(p=>{return{label:p,type:/^[A-Z]/.test(p)?"class":typeof window[p]=="function"?"function":"variable"};});
  //let jsCompletion=completeFromList([...keywords,...globals]);

  const editor = app.editor = window.editor = new EditorView({state:EditorState.create({
    doc: ``,
    extensions: [
      basicSetup,
      EditorState.tabSize.of(2),
      keymap.of([...tcBindings, defaultTabBinding]),
      tagExtension(app.tags.language, javascript()), //javascript(),
      //javascriptLanguage.data.of({autocomplete:jsCompletion}),
    ]
  }),parent:app.element});

  //* END CodeMirror6 */

  editor.focus();
  if (app.hasNwJs) {
    window.addEventListener("error", e=>alert(e.message));
    let searchFilepath = new URL(location).searchParams.get("filepath");
    let searchView = new URL(location).searchParams.get("view");
    if (searchView) app.dispatch({view:searchView});
    if (searchFilepath) {
      app.dispatch({data:`Loading "${searchFilepath}"…`});
      // XXX try to use File API instead
      // XXX use filepath=searchFilepath and app.reloadFile ?
      require("fs").readFile(searchFilepath, (err,buf)=>{
        if (err) return app.dispatch({data:`Fail to load "${searchFilepath}"!…\n${err}`});
        app.dispatch({data:new Uint8Array(buf),filepath:searchFilepath,modified:0,mode:app.extname(searchFilepath)});
      });
    }
  }

});  // window.onload end
})();
    </script>
    <script srcCodeMirror6=../third/codemirror6.js></script>
    <script src=../third/codemirror-5.59.4/bundle.js></script>
    <link rel=stylesheet href=../third/codemirror-5.59.4/bundle.css>
    <style>
:root{--body-default-margin:0px}
body{box-sizing:border-box;margin:var(--body-default-margin);min-height:calc(100vh - var(--body-default-margin) * 2)}
body.css-filter-invert{background-color:#000}
.css-filter-invert{filter:invert(100%)}
code,pre,.cm-wrap .cm-scroller{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace}

.CodeMirror{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace}
.cm-trailingspace { background-color: red; }
    </style>
  </head>
  <body onload="window.matchMedia('(prefers-color-scheme:dark)').matches&&document.body.classList.add('css-filter-invert')" onclick="if(event.target===document.body)editor.focus()"></body>
</html>
